import { useState, useRef, useEffect } from 'react'
import { useTranslation } from '../LanguageContext'
import styles from './DataPreview.module.css'

/**
 * Scrollable preview table showing the first N rows of parsed data.
 * Column headers are click-to-edit — clicking a name switches it to
 * a text input. Enter or blur commits the rename.
 *
 * Props:
 *   columns: [{ name, type, index }]
 *   rows: [[value, ...], ...]  — preview rows from the backend (first 20)
 *   onColumnRename(columnIndex, newName) — callback when a header is renamed
 *   headersAutoGenerated: boolean — true when no header row was detected
 */
export default function DataPreview({ columns, rows, onColumnRename, headersAutoGenerated }) {
  const t = useTranslation()

  if (!columns || !rows || rows.length === 0) return null

  return (
    <div className={styles.wrapper}>
      <h3 className={styles.heading}>
        {t.dataPreview}
        <span className={styles.rowCount}>({rows.length} {t.rowsShown})</span>
      </h3>

      {headersAutoGenerated && (
        <p className={styles.infoBanner}>
          {t.noHeaderDetected}
        </p>
      )}

      <div className={styles.tableContainer}>
        <table className={styles.table}>
          <thead>
            <tr>
              {columns.map((col) => (
                <EditableHeader
                  key={col.index}
                  column={col}
                  onRename={onColumnRename}
                />
              ))}
            </tr>
          </thead>
          <tbody>
            {rows.map((row, rowIdx) => (
              <tr key={rowIdx} className={rowIdx % 2 === 0 ? styles.rowEven : ''}>
                {columns.map((col) => (
                  <td key={col.index} className={styles.td}>
                    {formatCell(row[col.index], col.type)}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

/**
 * A single <th> that toggles between display mode and edit mode on click.
 */
function EditableHeader({ column, onRename }) {
  const [editing, setEditing] = useState(false)
  const [draft, setDraft] = useState(column.name)
  const inputRef = useRef(null)
  const t = useTranslation()

  // Sync draft when column name changes externally (e.g. new file uploaded)
  useEffect(() => {
    setDraft(column.name)
  }, [column.name])

  // Auto-focus and select the input text when entering edit mode
  useEffect(() => {
    if (editing && inputRef.current) {
      inputRef.current.focus()
      inputRef.current.select()
    }
  }, [editing])

  function commit() {
    setEditing(false)
    const trimmed = draft.trim()
    if (trimmed && trimmed !== column.name) {
      onRename(column.index, trimmed)
    } else {
      setDraft(column.name)
    }
  }

  function handleKeyDown(e) {
    if (e.key === 'Enter') {
      commit()
    } else if (e.key === 'Escape') {
      setDraft(column.name)
      setEditing(false)
    }
  }

  return (
    <th className={styles.th}>
      <span className={styles.headerWrap}>
        <span
          className={styles.colName}
          onClick={() => setEditing(true)}
          title={t.clickToRename}
          style={editing ? { visibility: 'hidden' } : undefined}
        >
          {column.name}
          <span className={styles.editIcon}>&#9998;</span>
        </span>
        {editing && (
          <input
            ref={inputRef}
            type="text"
            className={styles.headerInput}
            value={draft}
            onChange={(e) => setDraft(e.target.value)}
            onBlur={commit}
            onKeyDown={handleKeyDown}
          />
        )}
      </span>
      <span className={styles.colType}>{column.type}</span>
    </th>
  )
}

function formatCell(value, type) {
  if (value === null || value === undefined) {
    return <span className={styles.nullValue}>—</span>
  }
  if (type === 'numeric' && typeof value === 'number') {
    // Show up to 6 decimal places, no trailing zeros
    return Number.isInteger(value) ? value.toString() : parseFloat(value.toFixed(6)).toString()
  }
  return String(value)
}
