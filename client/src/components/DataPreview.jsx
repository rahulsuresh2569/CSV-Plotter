//DataPreview.jsx: scrollable preview table with click to edit column headers
import { useState, useRef, useEffect } from 'react'
import { useTranslation } from '../LanguageContext'
import styles from './DataPreview.module.css'

export default function DataPreview({ columns, rows, onColumnRename, headersAutoGenerated }) {
  const t = useTranslation()

  if (!columns || !rows || rows.length === 0) return null

  return (
    <div className={styles.wrapper}>
      <h3 className={styles.heading}>
        {t.dataPreview}
        <span className={styles.rowCount}>({rows.length} {t.rowsShown})</span>
      </h3>

      {headersAutoGenerated && (
        <p className={styles.infoBanner}>
          {t.noHeaderDetected}
        </p>
      )}

      <div className={styles.tableContainer}>
        <table className={styles.table}>
          <thead>
            <tr>
              {columns.map((col) => (
                <EditableHeader
                  key={col.index}
                  column={col}
                  onRename={onColumnRename}
                />
              ))}
            </tr>
          </thead>
          <tbody>
            {rows.map((row, rowIdx) => (
              <tr key={rowIdx} className={rowIdx % 2 === 0 ? styles.rowEven : ''}>
                {columns.map((col) => (
                  <td key={col.index} className={styles.td}>
                    {formatCell(row[col.index], col.type)}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

function EditableHeader({ column, onRename }) {
  const [editing, setEditing] = useState(false)
  const [draft, setDraft] = useState(column.name)
  const inputRef = useRef(null)
  const t = useTranslation()

  //sync draft when column name changes externally (new file uploaded)
  useEffect(() => {
    setDraft(column.name)
  }, [column.name])

  //auto-focus and select the input text when entering edit mode
  useEffect(() => {
    if (editing && inputRef.current) {
      inputRef.current.focus()
      inputRef.current.select()
    }
  }, [editing])

  function commit() {
    setEditing(false)
    const trimmed = draft.trim()
    if (trimmed && trimmed !== column.name) {
      onRename(column.index, trimmed)
    } else {
      setDraft(column.name)
    }
  }

  function handleKeyDown(e) {
    if (e.key === 'Enter') {
      commit()
    } else if (e.key === 'Escape') {
      setDraft(column.name)
      setEditing(false)
    }
  }

  return (
    <th className={styles.th}>
      <span className={styles.headerWrap}>
        <span
          className={styles.colName}
          onClick={() => setEditing(true)}
          title={t.clickToRename}
          style={editing ? { visibility: 'hidden' } : undefined}
        >
          {column.name}
          <span className={styles.editIcon}>&#9998;</span>
        </span>
        {editing && (
          <input
            ref={inputRef}
            type="text"
            className={styles.headerInput}
            value={draft}
            onChange={(e) => setDraft(e.target.value)}
            onBlur={commit}
            onKeyDown={handleKeyDown}
          />
        )}
      </span>
      <span className={styles.colType}>{typeIcon(column.type)} {column.type}</span>
    </th>
  )
}

function typeIcon(type) {
  const size = 11
  if (type === 'numeric') return <span className={styles.typeIcon}>#</span>
  if (type === 'date') return (
    <svg className={styles.typeIcon} width={size} height={size} viewBox="0 0 16 16" fill="currentColor">
      <path d="M4 0v1H2a2 2 0 0 0-2 2v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-2V0h-1v1H5V0H4zm-2 5h12v9H2V5zm2 2v2h2V7H4zm4 0v2h2V7H8zm4 0v2h2V7h-2z"/>
    </svg>
  )
  return <span className={styles.typeIcon}>Aa</span>
}

function formatCell(value, type) {
  if (value === null || value === undefined) {
    return <span className={styles.nullValue}>â€”</span>
  }
  if (type === 'numeric' && typeof value === 'number') {
    // Show up to 6 decimal places, no trailing zeros
    return Number.isInteger(value) ? value.toString() : parseFloat(value.toFixed(6)).toString()
  }
  return String(value)
}
